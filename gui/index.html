<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ3ä¸­å›½ç‰ˆèµ„æºä¸‹è½½å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a8e6cf 0%, #7fcdcd 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2d5a27;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #4a7c59;
            font-size: 1.1rem;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #2d5a27;
            font-weight: 600;
            font-size: 1rem;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 15px;
            border: 2px solid #c8e6c9;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            background: white;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #66bb6a;
        }

        input[type="text"][readonly] {
            cursor: pointer;
            background-color: #f8f9fa;
        }

        input[type="text"][readonly]:hover {
            background-color: #e9ecef;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #66bb6a;
            cursor: pointer;
        }

        select {
            cursor: pointer;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-button {
            background: #66bb6a;
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            display: inline-block;
            width: 100%;
            text-align: center;
            transition: background-color 0.3s ease;
            border: none;
            font-size: 1rem;
            font-weight: 600;
        }

        .file-input-button:hover {
            background: #5cb85c;
        }

        .file-name {
            margin-top: 10px;
            padding: 10px;
            background: #f1f8e9;
            border-radius: 5px;
            color: #4a7c59;
            display: none;
        }

        .submit-btn {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            margin-top: 20px;
        }

        .submit-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 187, 106, 0.3);
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .cancel-btn {
            background: #ef5350;
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
        }

        .cancel-btn:hover {
            background: #e53935;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(239, 83, 80, 0.3);
        }

        .progress-section {
            margin-top: 30px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e8f5e8;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #66bb6a, #4caf50);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .status-text {
            color: #2d5a27;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f1f8e9;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4caf50;
        }

        .stat-label {
            color: #4a7c59;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .log-section {
            margin-top: 20px;
            display: none;
        }

        .log-container {
            background: #1e2e1e;
            color: #a5d6a7;
            padding: 20px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-entry.info {
            color: #81c784;
        }

        .log-entry.error {
            color: #ef5350;
        }

        .log-entry.success {
            color: #66bb6a;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 data-i18n="app.title">PvZ3ä¸­å›½ç‰ˆèµ„æºä¸‹è½½å™¨</h1>
            <p data-i18n="app.description">Plants vs. Zombies 3 ä¸­å›½ç‰ˆæ¸¸æˆèµ„æºæ‰¹é‡ä¸‹è½½å·¥å…·</p>
        </div>

        <form id="downloadForm">
            <div class="form-group">
                <label for="language" data-i18n="form.language.label">è¯­è¨€ / Language</label>
                <select id="language">
                    <option value="zh-CN" data-i18n="form.language.chinese">ä¸­æ–‡</option>
                    <option value="en-US" data-i18n="form.language.english">English</option>
                </select>
            </div>

            <div class="form-group">
                <label for="downloadMode" data-i18n="form.downloadMode.label">ä¸‹è½½æ¨¡å¼</label>
                <select id="downloadMode">
                    <option value="standard" data-i18n="form.downloadMode.standard">ğŸ® æ ‡å‡†æ¨¡å¼ï¼ˆä¸­å›½ç‰ˆï¼‰</option>
                    <option value="custom" data-i18n="form.downloadMode.custom">âš™ï¸ è‡ªå®šä¹‰æ¨¡å¼</option>
                </select>
            </div>

            <div id="customModeFields" style="display: none;">
                <div class="form-group">
                    <label for="catalogSource" data-i18n="form.customCatalog.label">Catalogæ¥æº</label>
                    <select id="catalogSource">
                        <option value="file" data-i18n="form.customCatalog.fileOption">ä¸Šä¼ æœ¬åœ°æ–‡ä»¶</option>
                        <option value="url" data-i18n="form.customCatalog.urlOption">ä½¿ç”¨URL</option>
                    </select>
                </div>

                <div class="form-group" id="catalogFileGroup">
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="catalogFilePath" data-i18n-placeholder="form.customCatalog.selectFile" placeholder="é€‰æ‹©catalog.jsonæ–‡ä»¶" readonly style="flex: 1; cursor: pointer;">
                        <button type="button" id="selectCatalogBtn" class="file-input-button" style="width: auto; padding: 15px 20px; flex-shrink: 0;" data-i18n="form.customCatalog.selectFile">
                            ğŸ“„ é€‰æ‹©catalog.json
                        </button>
                    </div>
                </div>

                <div class="form-group" id="catalogUrlGroup" style="display: none;">
                    <input type="url" id="catalogUrl" data-i18n-placeholder="form.customCatalog.urlPlaceholder" placeholder="è¾“å…¥catalog.jsonçš„URL">
                    <small style="color: #4a7c59; display: block; margin-top: 5px;" data-i18n="form.customCatalog.urlHelp">ä¾‹å¦‚: https://example.com/catalog.json</small>
                </div>

                <div class="form-group">
                    <label for="customBaseUrl" data-i18n="form.customBaseUrl.label">èµ„æºåŸºç¡€URL</label>
                    <input type="url" id="customBaseUrl" data-i18n-placeholder="form.customBaseUrl.placeholder" placeholder="è¾“å…¥CDNåŸºç¡€URL" required>
                    <small style="color: #4a7c59; display: block; margin-top: 5px;" data-i18n="form.customBaseUrl.help">ä¾‹å¦‚: https://cdn.example.com/assets</small>
                </div>
            </div>

            <div class="form-group">
                <label for="platform" data-i18n="form.platform.label">é€‰æ‹©å¹³å°</label>
                <select id="platform" required>
                    <option value="" data-i18n="form.platform.placeholder">è¯·é€‰æ‹©å¹³å°</option>
                    <option value="iOS" data-i18n="form.platform.ios">ğŸ“± iOS</option>
                    <option value="Android" data-i18n="form.platform.android">ğŸ¤– Android</option>
                </select>
            </div>

            <div class="form-group">
                <label for="outputDir" data-i18n="form.outputDir.label">ä¸‹è½½ç›®å½•</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="outputDir" data-i18n-placeholder="form.outputDir.placeholder" placeholder="è¯·é€‰æ‹©ä¸‹è½½ç›®å½•" readonly style="flex: 1; cursor: pointer;">
                    <button type="button" id="selectDirBtn" class="file-input-button" style="width: auto; padding: 15px 20px; flex-shrink: 0;" data-i18n="form.outputDir.selectBtn">
                        ğŸ“ é€‰æ‹©ç›®å½•
                    </button>
                </div>
                <div style="margin-top: 10px; display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="createSubFolder" checked style="width: auto; margin: 0;">
                    <label for="createSubFolder" style="margin: 0; font-weight: normal; color: #4a7c59; cursor: pointer;" data-i18n="form.outputDir.createSubFolder">
                        åœ¨é€‰æ‹©çš„ç›®å½•ä¸‹åˆ›å»º "pvz3_downloads" æ–‡ä»¶å¤¹
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label for="concurrent" data-i18n="form.concurrent.label">æœ€å¤§å¹¶å‘æ•°</label>
                <input type="number" id="concurrent" value="10" min="1" max="50" required>
            </div>

            <button type="submit" class="submit-btn" id="submitBtn" data-i18n="buttons.startDownload">ğŸš€ å¼€å§‹ä¸‹è½½</button>
            <button type="button" class="cancel-btn" id="cancelBtn" style="display: none; margin-top: 15px;" data-i18n="buttons.stopDownload">ğŸ›‘ åœæ­¢ä¸‹è½½</button>
        </form>

        <div class="progress-section" id="progressSection">
            <div class="status-text" id="statusText" data-i18n="progress.preparing">å‡†å¤‡ä¸‹è½½...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalFiles">0</div>
                    <div class="stat-label" data-i18n="progress.totalFiles">æ€»æ–‡ä»¶</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="completedFiles">0</div>
                    <div class="stat-label" data-i18n="progress.completedFiles">å·²å®Œæˆ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="failedFiles">0</div>
                    <div class="stat-label" data-i18n="progress.failedFiles">å¤±è´¥</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="percentage">0%</div>
                    <div class="stat-label" data-i18n="progress.percentage">è¿›åº¦</div>
                </div>
            </div>
        </div>

        <div class="log-section" id="logSection">
            <div class="log-container" id="logContainer">
                <div class="log-entry info" data-i18n="messages.waiting">ç­‰å¾…å¼€å§‹ä¸‹è½½...</div>
            </div>
        </div>
    </div>

    <script>
        let downloadInProgress = false;
        let logContainer = document.getElementById('logContainer');
        let currentLanguage = 'zh-CN';
        let translations = {};

        // æ£€æŸ¥æ˜¯å¦åœ¨Electronç¯å¢ƒä¸­
        const isElectron = typeof window.electronAPI !== 'undefined';

        // åŠ è½½ç¿»è¯‘æ–‡ä»¶
        async function loadTranslations(lang) {
            try {
                const response = await fetch(`../locales/${lang}.json`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${lang}.json`);
                }
                translations = await response.json();
                return translations;
            } catch (error) {
                console.error('Error loading translations:', error);
                // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤çš„ä¸­æ–‡ç¿»è¯‘
                if (lang !== 'zh-CN') {
                    return await loadTranslations('zh-CN');
                }
                return {};
            }
        }

        // åº”ç”¨ç¿»è¯‘
        function applyTranslations() {
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = getTranslation(key);
                if (translation) {
                    if (element.tagName === 'INPUT' && element.type === 'text') {
                        element.placeholder = translation;
                    } else {
                        element.textContent = translation;
                    }
                }
            });

            // åº”ç”¨å ä½ç¬¦ç¿»è¯‘
            const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                const translation = getTranslation(key);
                if (translation) {
                    element.placeholder = translation;
                }
            });

            // æ›´æ–°æ–‡æ¡£æ ‡é¢˜
            document.title = getTranslation('app.title');
        }

        // è·å–ç¿»è¯‘æ–‡æœ¬
        function getTranslation(key) {
            const keys = key.split('.');
            let value = translations;
            for (const k of keys) {
                if (value && typeof value === 'object' && k in value) {
                    value = value[k];
                } else {
                    return null;
                }
            }
            return value;
        }

        // æ ¼å¼åŒ–ç¿»è¯‘æ–‡æœ¬ï¼ˆæ”¯æŒå‚æ•°æ›¿æ¢ï¼‰
        function formatTranslation(key, params = {}) {
            let text = getTranslation(key);
            if (!text) return key;
            
            // æ›¿æ¢å‚æ•°å ä½ç¬¦
            Object.keys(params).forEach(param => {
                const placeholder = `{${param}}`;
                text = text.replace(new RegExp(placeholder, 'g'), params[param]);
            });
            
            return text;
        }

        // åˆ‡æ¢è¯­è¨€
        async function switchLanguage(lang) {
            if (lang === currentLanguage) return;
            
            currentLanguage = lang;
            await loadTranslations(lang);
            applyTranslations();
            
            // ä¿å­˜è¯­è¨€è®¾ç½®
            if (isElectron) {
                try {
                    await window.electronAPI.saveUserConfig({ language: lang });
                } catch (error) {
                    console.error('Failed to save language setting:', error);
                }
            }
            
            addLog(formatTranslation('messages.languageChanged', { language: lang }), 'info');
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
            await initializeLanguage();
            
            if (isElectron) {
                initializeElectronListeners();
                loadAppInfo();
                loadUserConfig();
            }
            
            // è®¾ç½®è¯­è¨€åˆ‡æ¢äº‹ä»¶
            document.getElementById('language').addEventListener('change', function(e) {
                switchLanguage(e.target.value);
            });
            
            // è®¾ç½®ä¸‹è½½æ¨¡å¼åˆ‡æ¢äº‹ä»¶
            document.getElementById('downloadMode').addEventListener('change', function(e) {
                toggleCustomMode(e.target.value === 'custom');
            });
            
            // è®¾ç½®catalogæ¥æºåˆ‡æ¢äº‹ä»¶
            document.getElementById('catalogSource').addEventListener('change', function(e) {
                toggleCatalogSource(e.target.value);
            });
            
            // è®¾ç½®catalogæ–‡ä»¶é€‰æ‹©äº‹ä»¶
            document.getElementById('selectCatalogBtn').addEventListener('click', function() {
                selectCatalogFile();
            });
            
            document.getElementById('catalogFilePath').addEventListener('click', function() {
                selectCatalogFile();
            });
        });

        // åˆå§‹åŒ–è¯­è¨€
        async function initializeLanguage() {
            // é¦–å…ˆå°è¯•ä»ç”¨æˆ·é…ç½®åŠ è½½è¯­è¨€
            if (isElectron) {
                try {
                    const userConfig = await window.electronAPI.getUserConfig();
                    if (userConfig.language) {
                        currentLanguage = userConfig.language;
                    }
                } catch (error) {
                    console.error('Failed to load language from config:', error);
                }
            }
            
            // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œå°è¯•ä»æµè§ˆå™¨è¯­è¨€æ£€æµ‹
            if (!currentLanguage || currentLanguage === 'zh-CN') {
                const browserLang = navigator.language || navigator.userLanguage;
                if (browserLang.startsWith('en')) {
                    currentLanguage = 'en-US';
                } else {
                    currentLanguage = 'zh-CN';
                }
            }
            
            // è®¾ç½®è¯­è¨€é€‰æ‹©å™¨çš„å€¼
            document.getElementById('language').value = currentLanguage;
            
            // åŠ è½½ç¿»è¯‘æ–‡ä»¶å¹¶åº”ç”¨
            await loadTranslations(currentLanguage);
            applyTranslations();
        }

        // åŠ è½½ç”¨æˆ·é…ç½®
        async function loadUserConfig() {
            if (!isElectron) return;
            
            try {
                const userConfig = await window.electronAPI.getUserConfig();
                
                // è®¾ç½®é»˜è®¤å€¼
                if (userConfig.lastDownloadPath) {
                    document.getElementById('outputDir').value = userConfig.lastDownloadPath;
                    document.getElementById('outputDir').placeholder = userConfig.lastDownloadPath;
                }
                
                if (userConfig.lastPlatform) {
                    document.getElementById('platform').value = userConfig.lastPlatform;
                }
                
                if (userConfig.lastConcurrent) {
                    document.getElementById('concurrent').value = userConfig.lastConcurrent;
                }
                
                // è®¾ç½®åˆ›å»ºå­æ–‡ä»¶å¤¹é€‰é¡¹
                if (userConfig.createSubFolder !== undefined) {
                    document.getElementById('createSubFolder').checked = userConfig.createSubFolder;
                } else {
                    document.getElementById('createSubFolder').checked = true; // é»˜è®¤é€‰ä¸­
                }
                
                // è®¾ç½®è¯­è¨€
                if (userConfig.language && userConfig.language !== currentLanguage) {
                    await switchLanguage(userConfig.language);
                    document.getElementById('language').value = userConfig.language;
                }
                
                // è®¾ç½®ä¸‹è½½æ¨¡å¼
                if (userConfig.downloadMode) {
                    document.getElementById('downloadMode').value = userConfig.downloadMode;
                    toggleCustomMode(userConfig.downloadMode === 'custom');
                }
                
                // è®¾ç½®è‡ªå®šä¹‰é…ç½®
                if (userConfig.customCatalogSource) {
                    document.getElementById('catalogSource').value = userConfig.customCatalogSource;
                    toggleCatalogSource(userConfig.customCatalogSource);
                }
                
                if (userConfig.customCatalogUrl) {
                    document.getElementById('catalogUrl').value = userConfig.customCatalogUrl;
                }
                
                if (userConfig.customBaseUrl) {
                    document.getElementById('customBaseUrl').value = userConfig.customBaseUrl;
                }
                
                addLog(getTranslation('messages.loadedConfig'), 'info');
                
            } catch (error) {
                console.error('Failed to load user config:', error);
                addLog(getTranslation('messages.loadConfigFailed'), 'info');
            }
        }

        // åˆå§‹åŒ–Electronäº‹ä»¶ç›‘å¬å™¨
        function initializeElectronListeners() {
            // ä¸‹è½½äº‹ä»¶ç›‘å¬
            window.electronAPI.onDownloadStarted((event, data) => {
                addLog(formatTranslation('log.downloadStarted', { platform: data.platform.toUpperCase(), outputDir: data.outputDir }), 'info');
            });

            window.electronAPI.onDownloadCompleted((event, stats) => {
                const message = formatTranslation('log.downloadComplete', {
                    total: stats.total,
                    success: stats.success,
                    failed: stats.failed
                });
                addLog(message, stats.failed === 0 ? 'success' : 'error');
                onDownloadStopped();
            });

            window.electronAPI.onDownloadStopped((event) => {
                addLog(getTranslation('messages.downloadStopped'), 'info');
                onDownloadStopped();
            });

            window.electronAPI.onDownloadError((event, data) => {
                addLog(getTranslation('messages.downloadError') + data.error, 'error');
                onDownloadStopped();
            });

            window.electronAPI.onProgressUpdate((event, progress) => {
                updateProgress(progress);
            });

            window.electronAPI.onLogMessage((event, data) => {
                addLog(data.message, data.level);
            });

            window.electronAPI.onDirectorySelected((event, dirPath) => {
                document.getElementById('outputDir').value = dirPath;
                addLog(getTranslation('messages.directorySelected') + dirPath, 'info');
            });
        }

        // åŠ è½½åº”ç”¨ä¿¡æ¯
        async function loadAppInfo() {
            if (isElectron) {
                try {
                    const version = await window.electronAPI.getAppVersion();
                    const systemInfo = window.electronAPI.getSystemInfo();
                    const config = await window.electronAPI.getDownloadConfig();
                    addLog(formatTranslation('log.appInfo', {
                        version: version,
                        platform: systemInfo.platform,
                        arch: systemInfo.arch
                    }), 'info');
                    addLog(formatTranslation('log.downloadConfig', {
                        maxRetries: config.maxRetries,
                        timeout: config.timeout/1000
                    }), 'info');
                } catch (error) {
                    console.error('Failed to load app info:', error);
                }
            }
        }

        // åˆ‡æ¢è‡ªå®šä¹‰æ¨¡å¼æ˜¾ç¤º/éšè—
        function toggleCustomMode(isCustom) {
            const customFields = document.getElementById('customModeFields');
            customFields.style.display = isCustom ? 'block' : 'none';
            
            // åˆ‡æ¢æ—¶ä¿å­˜è®¾ç½®
            if (isElectron) {
                window.electronAPI.saveUserConfig({
                    downloadMode: isCustom ? 'custom' : 'standard'
                }).catch(error => {
                    console.error('Failed to save download mode:', error);
                });
            }
        }
        
        // åˆ‡æ¢catalogæ¥æº
        function toggleCatalogSource(source) {
            const fileGroup = document.getElementById('catalogFileGroup');
            const urlGroup = document.getElementById('catalogUrlGroup');
            
            if (source === 'file') {
                fileGroup.style.display = 'block';
                urlGroup.style.display = 'none';
            } else {
                fileGroup.style.display = 'none';
                urlGroup.style.display = 'block';
            }
            
            // ä¿å­˜è®¾ç½®
            if (isElectron) {
                window.electronAPI.saveUserConfig({
                    customCatalogSource: source
                }).catch(error => {
                    console.error('Failed to save catalog source:', error);
                });
            }
        }
        
        // é€‰æ‹©catalogæ–‡ä»¶
        let selectedCatalogPath = '';
        async function selectCatalogFile() {
            if (!isElectron) {
                alert(getTranslation('messages.needElectron'));
                return;
            }
            
            try {
                const result = await window.electronAPI.selectCatalogFile();
                if (result.success) {
                    selectedCatalogPath = result.filePath;
                    document.getElementById('catalogFilePath').value = result.filename;
                    addLog(getTranslation('messages.catalogFileSelected') + result.filename, 'info');
                }
            } catch (error) {
                addLog(getTranslation('messages.catalogFileSelectError') + error.message, 'error');
            }
        }

        // è¡¨å•æäº¤å¤„ç†
        document.getElementById('downloadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (downloadInProgress) {
                return;
            }

            const platform = document.getElementById('platform').value;
            const outputDir = document.getElementById('outputDir').value.trim();
            const concurrent = parseInt(document.getElementById('concurrent').value);
            const createSubFolder = document.getElementById('createSubFolder').checked;
            const downloadMode = document.getElementById('downloadMode').value;

            if (!platform) {
                alert(getTranslation('messages.selectPlatform'));
                return;
            }

            if (!outputDir) {
                alert(getTranslation('messages.selectDirectory'));
                return;
            }

            // æ„å»ºè‡ªå®šä¹‰é…ç½®
            let customConfig = null;
            if (downloadMode === 'custom') {
                const catalogSource = document.getElementById('catalogSource').value;
                const customBaseUrl = document.getElementById('customBaseUrl').value.trim();
                
                if (!customBaseUrl) {
                    alert(getTranslation('messages.provideBaseUrl'));
                    return;
                }
                
                // éªŒè¯base URL
                try {
                    new URL(customBaseUrl);
                } catch (e) {
                    alert(getTranslation('messages.invalidBaseUrl'));
                    return;
                }
                
                if (catalogSource === 'file') {
                    if (!selectedCatalogPath) {
                        alert(getTranslation('messages.selectCatalogFile'));
                        return;
                    }
                    customConfig = {
                        mode: 'custom',
                        catalogSource: 'file',
                        catalogFilePath: selectedCatalogPath,
                        baseUrl: customBaseUrl
                    };
                } else {
                    const catalogUrl = document.getElementById('catalogUrl').value.trim();
                    if (!catalogUrl) {
                        alert(getTranslation('messages.provideCatalogUrl'));
                        return;
                    }
                    
                    // éªŒè¯catalog URL
                    try {
                        new URL(catalogUrl);
                    } catch (e) {
                        alert(getTranslation('messages.invalidCatalogUrl'));
                        return;
                    }
                    
                    customConfig = {
                        mode: 'custom',
                        catalogSource: 'url',
                        catalogUrl: catalogUrl,
                        baseUrl: customBaseUrl
                    };
                }
            }

            // ä¿å­˜ç”¨æˆ·é€‰æ‹©
            if (isElectron) {
                try {
                    const configToSave = {
                        lastPlatform: platform,
                        lastDownloadPath: outputDir,
                        lastConcurrent: concurrent,
                        createSubFolder: createSubFolder
                    };
                    
                    if (customConfig) {
                        configToSave.downloadMode = 'custom';
                        configToSave.customCatalogSource = customConfig.catalogSource;
                        configToSave.customCatalogUrl = customConfig.catalogUrl || '';
                        configToSave.customBaseUrl = customConfig.baseUrl;
                    }
                    
                    await window.electronAPI.saveUserConfig(configToSave);
                } catch (error) {
                    console.error('Failed to save user config:', error);
                }
            }

            // å¼€å§‹ä¸‹è½½
            if (isElectron) {
                await startDownloadElectron(platform, outputDir, concurrent, createSubFolder, customConfig);
            } else {
                alert(getTranslation('messages.needElectron'));
            }
        });

        // åœæ­¢ä¸‹è½½å¤„ç†
        document.getElementById('cancelBtn').addEventListener('click', async function() {
            if (!downloadInProgress || !isElectron) {
                return;
            }
            
            try {
                const result = await window.electronAPI.stopDownload();
                if (result.success) {
                    addLog(getTranslation('log.stopRequested'), 'info');
                } else {
                    addLog(getTranslation('log.stopFailed'), 'error');
                }
            } catch (error) {
                addLog(getTranslation('messages.downloadError') + error.message, 'error');
            }
        });

        // é€‰æ‹©ç›®å½•æŒ‰é’®å¤„ç†
        document.addEventListener('click', function(e) {
            if (e.target.id === 'selectDirBtn') {
                selectDirectory();
            } else if (e.target.id === 'outputDir') {
                // ç‚¹å‡»è¾“å…¥æ¡†ä¹Ÿè§¦å‘ç›®å½•é€‰æ‹©
                selectDirectory();
            }
        });

        // ç›‘å¬å¤é€‰æ¡†å˜åŒ–ï¼Œå®æ—¶ä¿å­˜é…ç½®
        document.addEventListener('change', function(e) {
            if (e.target.id === 'createSubFolder' && isElectron) {
                const createSubFolder = e.target.checked;
                try {
                    window.electronAPI.saveUserConfig({
                        createSubFolder: createSubFolder
                    }).then(() => {
                        addLog(createSubFolder ? getTranslation('messages.createSubFolderEnabled') : getTranslation('messages.createSubFolderDisabled'), 'info');
                    }).catch(error => {
                        console.error('Failed to save config:', error);
                    });
                } catch (error) {
                    console.error('Failed to save config:', error);
                }
            }
        });

        async function selectDirectory() {
            if (!isElectron) {
                alert(getTranslation('messages.needElectron'));
                return;
            }

            try {
                const selectedPath = await window.electronAPI.selectDirectory();
                if (selectedPath) {
                    document.getElementById('outputDir').value = selectedPath;
                    document.getElementById('outputDir').placeholder = selectedPath;
                    addLog(getTranslation('messages.directorySelected') + selectedPath, 'info');
                    
                    // ä¿å­˜åˆ°ç”¨æˆ·é…ç½®
                    const createSubFolder = document.getElementById('createSubFolder').checked;
                    await window.electronAPI.saveUserConfig({
                        lastDownloadPath: selectedPath,
                        createSubFolder: createSubFolder
                    });
                }
            } catch (error) {
                addLog(getTranslation('messages.directorySelectError') + error.message, 'error');
            }
        }

        async function startDownloadElectron(platform, outputDir, concurrent, createSubFolder, customConfig = null) {
            downloadInProgress = true;
            
            // æ˜¾ç¤ºè¿›åº¦åŒºåŸŸå’Œæ—¥å¿—åŒºåŸŸ
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('logSection').style.display = 'block';
            
            // ç¦ç”¨æäº¤æŒ‰é’®ï¼Œæ˜¾ç¤ºå–æ¶ˆæŒ‰é’®
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = getTranslation('buttons.downloading');
            cancelBtn.style.display = 'block';

            // æ¸…ç©ºæ—¥å¿—
            logContainer.innerHTML = '';
            
            try {
                addLog(formatTranslation('log.startingDownload', { platform: platform.toUpperCase() }), 'info');
                
                const result = await window.electronAPI.startDownload({
                    platform: platform,
                    outputDir: outputDir,
                    concurrent: concurrent,
                    createSubFolder: createSubFolder,
                    customConfig: customConfig
                });

                if (result && !result.success) {
                    addLog(getTranslation('log.downloadStartFailed') + result.error, 'error');
                    onDownloadStopped();
                }

            } catch (error) {
                addLog(getTranslation('log.error') + error.message, 'error');
                onDownloadStopped();
            }
        }

        function updateProgress(data) {
            const { total, completed, failed, currentFile } = data;
            
            document.getElementById('totalFiles').textContent = total || 0;
            document.getElementById('completedFiles').textContent = completed || 0;
            document.getElementById('failedFiles').textContent = failed || 0;
            
            const percentage = total > 0 ? Math.round((completed + failed) / total * 100) : 0;
            document.getElementById('percentage').textContent = percentage + '%';
            document.getElementById('progressFill').style.width = percentage + '%';
            
            if (currentFile) {
                document.getElementById('statusText').textContent = getTranslation('progress.downloading') + ': ' + currentFile;
            }
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (total > 0 && (completed + failed) >= total) {
                document.getElementById('statusText').textContent = failed === 0 ? getTranslation('progress.completed') : getTranslation('progress.completedWithErrors');
            }
        }

        function addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // åœæ­¢ä¸‹è½½çŠ¶æ€æ›´æ–°
        function onDownloadStopped() {
            downloadInProgress = false;
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            submitBtn.disabled = false;
            submitBtn.textContent = getTranslation('buttons.startDownload');
            cancelBtn.style.display = 'none';
            
            const statusText = document.getElementById('statusText');
            if (!statusText.textContent.includes(getTranslation('progress.completed').split('!')[0])) {
                statusText.textContent = getTranslation('progress.stopped');
            }
        }

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            console.error('Global error:', e);
            addLog(getTranslation('messages.appError') + e.message, 'error');
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e);
            addLog(getTranslation('messages.asyncError') + e.reason, 'error');
        });
    </script>
</body>
</html>