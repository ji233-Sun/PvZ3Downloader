<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ3‰∏≠ÂõΩÁâàËµÑÊ∫ê‰∏ãËΩΩÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a8e6cf 0%, #7fcdcd 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2d5a27;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #4a7c59;
            font-size: 1.1rem;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #2d5a27;
            font-weight: 600;
            font-size: 1rem;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 15px;
            border: 2px solid #c8e6c9;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            background: white;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #66bb6a;
        }

        input[type="text"][readonly] {
            cursor: pointer;
            background-color: #f8f9fa;
        }

        input[type="text"][readonly]:hover {
            background-color: #e9ecef;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #66bb6a;
            cursor: pointer;
        }

        select {
            cursor: pointer;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-button {
            background: #66bb6a;
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            display: inline-block;
            width: 100%;
            text-align: center;
            transition: background-color 0.3s ease;
            border: none;
            font-size: 1rem;
            font-weight: 600;
        }

        .file-input-button:hover {
            background: #5cb85c;
        }

        .file-name {
            margin-top: 10px;
            padding: 10px;
            background: #f1f8e9;
            border-radius: 5px;
            color: #4a7c59;
            display: none;
        }

        .submit-btn {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            margin-top: 20px;
        }

        .submit-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 187, 106, 0.3);
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .cancel-btn {
            background: #ef5350;
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
        }

        .cancel-btn:hover {
            background: #e53935;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(239, 83, 80, 0.3);
        }

        .progress-section {
            margin-top: 30px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e8f5e8;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #66bb6a, #4caf50);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .status-text {
            color: #2d5a27;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f1f8e9;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4caf50;
        }

        .stat-label {
            color: #4a7c59;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .log-section {
            margin-top: 20px;
            display: none;
        }

        .log-container {
            background: #1e2e1e;
            color: #a5d6a7;
            padding: 20px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-entry.info {
            color: #81c784;
        }

        .log-entry.error {
            color: #ef5350;
        }

        .log-entry.success {
            color: #66bb6a;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 data-i18n="app.title">PvZ3‰∏≠ÂõΩÁâàËµÑÊ∫ê‰∏ãËΩΩÂô®</h1>
            <p data-i18n="app.description">Plants vs. Zombies 3 ‰∏≠ÂõΩÁâàÊ∏∏ÊàèËµÑÊ∫êÊâπÈáè‰∏ãËΩΩÂ∑•ÂÖ∑</p>
        </div>

        <form id="downloadForm">
            <div class="form-group">
                <label for="language" data-i18n="form.language.label">ËØ≠Ë®Ä / Language</label>
                <select id="language">
                    <option value="zh-CN" data-i18n="form.language.chinese">‰∏≠Êñá</option>
                    <option value="en-US" data-i18n="form.language.english">English</option>
                </select>
            </div>

            <div class="form-group">
                <label for="downloadMode" data-i18n="form.downloadMode.label">‰∏ãËΩΩÊ®°Âºè</label>
                <select id="downloadMode">
                    <option value="standard" data-i18n="form.downloadMode.standard">üéÆ Ê†áÂáÜÊ®°ÂºèÔºà‰∏≠ÂõΩÁâàÔºâ</option>
                    <option value="custom" data-i18n="form.downloadMode.custom">‚öôÔ∏è Ëá™ÂÆö‰πâÊ®°Âºè</option>
                </select>
            </div>

            <div id="customModeFields" style="display: none;">
                <div class="form-group">
                    <label for="catalogSource" data-i18n="form.customCatalog.label">CatalogÊù•Ê∫ê</label>
                    <select id="catalogSource">
                        <option value="file" data-i18n="form.customCatalog.fileOption">‰∏ä‰º†Êú¨Âú∞Êñá‰ª∂</option>
                        <option value="url" data-i18n="form.customCatalog.urlOption">‰ΩøÁî®URL</option>
                    </select>
                </div>

                <div class="form-group" id="catalogFileGroup">
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="catalogFilePath" data-i18n-placeholder="form.customCatalog.selectFile" placeholder="ÈÄâÊã©catalog.jsonÊñá‰ª∂" readonly style="flex: 1; cursor: pointer;">
                        <button type="button" id="selectCatalogBtn" class="file-input-button" style="width: auto; padding: 15px 20px; flex-shrink: 0;" data-i18n="form.customCatalog.selectFile">
                            üìÑ ÈÄâÊã©catalog.json
                        </button>
                    </div>
                </div>

                <div class="form-group" id="catalogUrlGroup" style="display: none;">
                    <input type="url" id="catalogUrl" data-i18n-placeholder="form.customCatalog.urlPlaceholder" placeholder="ËæìÂÖ•catalog.jsonÁöÑURL">
                    <small style="color: #4a7c59; display: block; margin-top: 5px;" data-i18n="form.customCatalog.urlHelp">‰æãÂ¶Ç: https://example.com/catalog.json</small>
                </div>

                <div class="form-group">
                    <label for="customBaseUrl" data-i18n="form.customBaseUrl.label">ËµÑÊ∫êÂü∫Á°ÄURL</label>
                    <input type="url" id="customBaseUrl" data-i18n-placeholder="form.customBaseUrl.placeholder" placeholder="ËæìÂÖ•CDNÂü∫Á°ÄURL" required>
                    <small style="color: #4a7c59; display: block; margin-top: 5px;" data-i18n="form.customBaseUrl.help">‰æãÂ¶Ç: https://cdn.example.com/assets</small>
                </div>
            </div>

            <div class="form-group">
                <label for="platform" data-i18n="form.platform.label">ÈÄâÊã©Âπ≥Âè∞</label>
                <select id="platform" required>
                    <option value="" data-i18n="form.platform.placeholder">ËØ∑ÈÄâÊã©Âπ≥Âè∞</option>
                    <option value="iOS" data-i18n="form.platform.ios">üì± iOS</option>
                    <option value="Android" data-i18n="form.platform.android">ü§ñ Android</option>
                </select>
            </div>

            <div class="form-group">
                <label for="outputDir" data-i18n="form.outputDir.label">‰∏ãËΩΩÁõÆÂΩï</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="outputDir" data-i18n-placeholder="form.outputDir.placeholder" placeholder="ËØ∑ÈÄâÊã©‰∏ãËΩΩÁõÆÂΩï" readonly style="flex: 1; cursor: pointer;">
                    <button type="button" id="selectDirBtn" class="file-input-button" style="width: auto; padding: 15px 20px; flex-shrink: 0;" data-i18n="form.outputDir.selectBtn">
                        üìÅ ÈÄâÊã©ÁõÆÂΩï
                    </button>
                </div>
                <div style="margin-top: 10px; display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="createSubFolder" checked style="width: auto; margin: 0;">
                    <label for="createSubFolder" style="margin: 0; font-weight: normal; color: #4a7c59; cursor: pointer;" data-i18n="form.outputDir.createSubFolder">
                        Âú®ÈÄâÊã©ÁöÑÁõÆÂΩï‰∏ãÂàõÂª∫ "pvz3_downloads" Êñá‰ª∂Â§π
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label for="concurrent" data-i18n="form.concurrent.label">ÊúÄÂ§ßÂπ∂ÂèëÊï∞</label>
                <input type="number" id="concurrent" value="10" min="1" max="50" required>
            </div>

            <button type="submit" class="submit-btn" id="submitBtn" data-i18n="buttons.startDownload">üöÄ ÂºÄÂßã‰∏ãËΩΩ</button>
            <button type="button" class="cancel-btn" id="cancelBtn" style="display: none; margin-top: 15px;" data-i18n="buttons.stopDownload">üõë ÂÅúÊ≠¢‰∏ãËΩΩ</button>
        </form>

        <div class="progress-section" id="progressSection">
            <div class="status-text" id="statusText" data-i18n="progress.preparing">ÂáÜÂ§á‰∏ãËΩΩ...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalFiles">0</div>
                    <div class="stat-label" data-i18n="progress.totalFiles">ÊÄªÊñá‰ª∂</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="completedFiles">0</div>
                    <div class="stat-label" data-i18n="progress.completedFiles">Â∑≤ÂÆåÊàê</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="failedFiles">0</div>
                    <div class="stat-label" data-i18n="progress.failedFiles">Â§±Ë¥•</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="percentage">0%</div>
                    <div class="stat-label" data-i18n="progress.percentage">ËøõÂ∫¶</div>
                </div>
            </div>
        </div>

        <div class="log-section" id="logSection">
            <div class="log-container" id="logContainer">
                <div class="log-entry info" data-i18n="messages.waiting">Á≠âÂæÖÂºÄÂßã‰∏ãËΩΩ...</div>
            </div>
        </div>
    </div>

    <script>
        let downloadInProgress = false;
        let logContainer = document.getElementById('logContainer');
        let currentLanguage = 'zh-CN';
        let translations = {};

        // Ê£ÄÊü•ÊòØÂê¶Âú®ElectronÁéØÂ¢É‰∏≠
        const isElectron = typeof window.electronAPI !== 'undefined';

        // Âä†ËΩΩÁøªËØëÊñá‰ª∂
        async function loadTranslations(lang) {
            try {
                const response = await fetch(`../locales/${lang}.json`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${lang}.json`);
                }
                translations = await response.json();
                return translations;
            } catch (error) {
                console.error('Error loading translations:', error);
                // Â¶ÇÊûúÂä†ËΩΩÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÁöÑ‰∏≠ÊñáÁøªËØë
                if (lang !== 'zh-CN') {
                    return await loadTranslations('zh-CN');
                }
                return {};
            }
        }

        // Â∫îÁî®ÁøªËØë
        function applyTranslations() {
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = getTranslation(key);
                if (translation) {
                    if (element.tagName === 'INPUT' && element.type === 'text') {
                        element.placeholder = translation;
                    } else {
                        element.textContent = translation;
                    }
                }
            });

            // Â∫îÁî®Âç†‰ΩçÁ¨¶ÁøªËØë
            const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
            placeholderElements.forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                const translation = getTranslation(key);
                if (translation) {
                    element.placeholder = translation;
                }
            });

            // Êõ¥Êñ∞ÊñáÊ°£Ê†áÈ¢ò
            document.title = getTranslation('app.title');
        }

        // Ëé∑ÂèñÁøªËØëÊñáÊú¨
        function getTranslation(key) {
            const keys = key.split('.');
            let value = translations;
            for (const k of keys) {
                if (value && typeof value === 'object' && k in value) {
                    value = value[k];
                } else {
                    return null;
                }
            }
            return value;
        }

        // Ê†ºÂºèÂåñÁøªËØëÊñáÊú¨ÔºàÊîØÊåÅÂèÇÊï∞ÊõøÊç¢Ôºâ
        function formatTranslation(key, params = {}) {
            let text = getTranslation(key);
            if (!text) return key;
            
            // ÊõøÊç¢ÂèÇÊï∞Âç†‰ΩçÁ¨¶
            Object.keys(params).forEach(param => {
                const placeholder = `{${param}}`;
                text = text.replace(new RegExp(placeholder, 'g'), params[param]);
            });
            
            return text;
        }

        // ÂàáÊç¢ËØ≠Ë®Ä
        async function switchLanguage(lang) {
            if (lang === currentLanguage) return;
            
            currentLanguage = lang;
            await loadTranslations(lang);
            applyTranslations();
            
            // ‰øùÂ≠òËØ≠Ë®ÄËÆæÁΩÆ
            if (isElectron) {
                try {
                    await window.electronAPI.saveUserConfig({ language: lang });
                } catch (error) {
                    console.error('Failed to save language setting:', error);
                }
            }
            
            addLog(formatTranslation('messages.languageChanged', { language: lang }), 'info');
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', async function() {
            // ÂàùÂßãÂåñËØ≠Ë®ÄËÆæÁΩÆ
            await initializeLanguage();
            
            if (isElectron) {
                initializeElectronListeners();
                loadAppInfo();
                loadUserConfig();
            }
            
            // ËÆæÁΩÆËØ≠Ë®ÄÂàáÊç¢‰∫ã‰ª∂
            document.getElementById('language').addEventListener('change', function(e) {
                switchLanguage(e.target.value);
            });
            
            // ËÆæÁΩÆ‰∏ãËΩΩÊ®°ÂºèÂàáÊç¢‰∫ã‰ª∂
            document.getElementById('downloadMode').addEventListener('change', function(e) {
                toggleCustomMode(e.target.value === 'custom');
            });
            
            // ËÆæÁΩÆcatalogÊù•Ê∫êÂàáÊç¢‰∫ã‰ª∂
            document.getElementById('catalogSource').addEventListener('change', function(e) {
                toggleCatalogSource(e.target.value);
            });
            
            // ËÆæÁΩÆcatalogÊñá‰ª∂ÈÄâÊã©‰∫ã‰ª∂
            document.getElementById('selectCatalogBtn').addEventListener('click', function() {
                selectCatalogFile();
            });
            
            document.getElementById('catalogFilePath').addEventListener('click', function() {
                selectCatalogFile();
            });
        });

        // ÂàùÂßãÂåñËØ≠Ë®Ä
        async function initializeLanguage() {
            // È¶ñÂÖàÂ∞ùËØï‰ªéÁî®Êà∑ÈÖçÁΩÆÂä†ËΩΩËØ≠Ë®Ä
            if (isElectron) {
                try {
                    const userConfig = await window.electronAPI.getUserConfig();
                    if (userConfig.language) {
                        currentLanguage = userConfig.language;
                    }
                } catch (error) {
                    console.error('Failed to load language from config:', error);
                }
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÈÖçÁΩÆÔºåÂ∞ùËØï‰ªéÊµèËßàÂô®ËØ≠Ë®ÄÊ£ÄÊµã
            if (!currentLanguage || currentLanguage === 'zh-CN') {
                const browserLang = navigator.language || navigator.userLanguage;
                if (browserLang.startsWith('en')) {
                    currentLanguage = 'en-US';
                } else {
                    currentLanguage = 'zh-CN';
                }
            }
            
            // ËÆæÁΩÆËØ≠Ë®ÄÈÄâÊã©Âô®ÁöÑÂÄº
            document.getElementById('language').value = currentLanguage;
            
            // Âä†ËΩΩÁøªËØëÊñá‰ª∂Âπ∂Â∫îÁî®
            await loadTranslations(currentLanguage);
            applyTranslations();
        }

        // Âä†ËΩΩÁî®Êà∑ÈÖçÁΩÆ
        async function loadUserConfig() {
            if (!isElectron) return;
            
            try {
                const userConfig = await window.electronAPI.getUserConfig();
                
                // ËÆæÁΩÆÈªòËÆ§ÂÄº
                if (userConfig.lastDownloadPath) {
                    document.getElementById('outputDir').value = userConfig.lastDownloadPath;
                    document.getElementById('outputDir').placeholder = userConfig.lastDownloadPath;
                }
                
                if (userConfig.lastPlatform) {
                    document.getElementById('platform').value = userConfig.lastPlatform;
                }
                
                if (userConfig.lastConcurrent) {
                    document.getElementById('concurrent').value = userConfig.lastConcurrent;
                }
                
                // ËÆæÁΩÆÂàõÂª∫Â≠êÊñá‰ª∂Â§πÈÄâÈ°π
                if (userConfig.createSubFolder !== undefined) {
                    document.getElementById('createSubFolder').checked = userConfig.createSubFolder;
                } else {
                    document.getElementById('createSubFolder').checked = true; // ÈªòËÆ§ÈÄâ‰∏≠
                }
                
                // ËÆæÁΩÆËØ≠Ë®Ä
                if (userConfig.language && userConfig.language !== currentLanguage) {
                    await switchLanguage(userConfig.language);
                    document.getElementById('language').value = userConfig.language;
                }
                
                // ËÆæÁΩÆ‰∏ãËΩΩÊ®°Âºè
                if (userConfig.downloadMode) {
                    document.getElementById('downloadMode').value = userConfig.downloadMode;
                    toggleCustomMode(userConfig.downloadMode === 'custom');
                }
                
                // ËÆæÁΩÆËá™ÂÆö‰πâÈÖçÁΩÆ
                if (userConfig.customCatalogSource) {
                    document.getElementById('catalogSource').value = userConfig.customCatalogSource;
                    toggleCatalogSource(userConfig.customCatalogSource);
                }
                
                if (userConfig.customCatalogUrl) {
                    document.getElementById('catalogUrl').value = userConfig.customCatalogUrl;
                }
                
                if (userConfig.customBaseUrl) {
                    document.getElementById('customBaseUrl').value = userConfig.customBaseUrl;
                }
                
                addLog(getTranslation('messages.loadedConfig'), 'info');
                
            } catch (error) {
                console.error('Failed to load user config:', error);
                addLog(getTranslation('messages.loadConfigFailed'), 'info');
            }
        }

        // ÂàùÂßãÂåñElectron‰∫ã‰ª∂ÁõëÂê¨Âô®
        function initializeElectronListeners() {
            // ‰∏ãËΩΩ‰∫ã‰ª∂ÁõëÂê¨
            window.electronAPI.onDownloadStarted((event, data) => {
                addLog(formatTranslation('log.downloadStarted', { platform: data.platform.toUpperCase(), outputDir: data.outputDir }), 'info');
            });

            window.electronAPI.onDownloadCompleted((event, stats) => {
                const message = formatTranslation('log.downloadComplete', {
                    total: stats.total,
                    success: stats.success,
                    failed: stats.failed
                });
                addLog(message, stats.failed === 0 ? 'success' : 'error');
                onDownloadStopped();
            });

            window.electronAPI.onDownloadStopped((event) => {
                addLog(getTranslation('messages.downloadStopped'), 'info');
                onDownloadStopped();
            });

            window.electronAPI.onDownloadError((event, data) => {
                addLog(getTranslation('messages.downloadError') + data.error, 'error');
                onDownloadStopped();
            });

            window.electronAPI.onProgressUpdate((event, progress) => {
                updateProgress(progress);
            });

            window.electronAPI.onLogMessage((event, data) => {
                addLog(data.message, data.level);
            });

            window.electronAPI.onDirectorySelected((event, dirPath) => {
                document.getElementById('outputDir').value = dirPath;
                addLog(getTranslation('messages.directorySelected') + dirPath, 'info');
            });
        }

        // Âä†ËΩΩÂ∫îÁî®‰ø°ÊÅØ
        async function loadAppInfo() {
            if (isElectron) {
                try {
                    const version = await window.electronAPI.getAppVersion();
                    const systemInfo = window.electronAPI.getSystemInfo();
                    const config = await window.electronAPI.getDownloadConfig();
                    addLog(formatTranslation('log.appInfo', {
                        version: version,
                        platform: systemInfo.platform,
                        arch: systemInfo.arch
                    }), 'info');
                    addLog(formatTranslation('log.downloadConfig', {
                        maxRetries: config.maxRetries,
                        timeout: config.timeout/1000
                    }), 'info');
                } catch (error) {
                    console.error('Failed to load app info:', error);
                }
            }
        }

        // ÂàáÊç¢Ëá™ÂÆö‰πâÊ®°ÂºèÊòæÁ§∫/ÈöêËóè
        function toggleCustomMode(isCustom) {
            const customFields = document.getElementById('customModeFields');
            customFields.style.display = isCustom ? 'block' : 'none';
            
            // ÂàáÊç¢Êó∂‰øùÂ≠òËÆæÁΩÆ
            if (isElectron) {
                window.electronAPI.saveUserConfig({
                    downloadMode: isCustom ? 'custom' : 'standard'
                }).catch(error => {
                    console.error('Failed to save download mode:', error);
                });
            }
        }
        
        // ÂàáÊç¢catalogÊù•Ê∫ê
        function toggleCatalogSource(source) {
            const fileGroup = document.getElementById('catalogFileGroup');
            const urlGroup = document.getElementById('catalogUrlGroup');
            
            if (source === 'file') {
                fileGroup.style.display = 'block';
                urlGroup.style.display = 'none';
            } else {
                fileGroup.style.display = 'none';
                urlGroup.style.display = 'block';
            }
            
            // ‰øùÂ≠òËÆæÁΩÆ
            if (isElectron) {
                window.electronAPI.saveUserConfig({
                    customCatalogSource: source
                }).catch(error => {
                    console.error('Failed to save catalog source:', error);
                });
            }
        }
        
        // ÈÄâÊã©catalogÊñá‰ª∂
        let selectedCatalogPath = '';
        async function selectCatalogFile() {
            if (!isElectron) {
                alert(getTranslation('messages.needElectron'));
                return;
            }
            
            try {
                const result = await window.electronAPI.selectCatalogFile();
                if (result.success) {
                    selectedCatalogPath = result.filePath;
                    document.getElementById('catalogFilePath').value = result.filename;
                    addLog(getTranslation('messages.catalogFileSelected') + result.filename, 'info');
                }
            } catch (error) {
                addLog(getTranslation('messages.catalogFileSelectError') + error.message, 'error');
            }
        }

        // Ë°®ÂçïÊèê‰∫§Â§ÑÁêÜ
        document.getElementById('downloadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (downloadInProgress) {
                return;
            }

            const platform = document.getElementById('platform').value;
            const outputDir = document.getElementById('outputDir').value.trim();
            const concurrent = parseInt(document.getElementById('concurrent').value);
            const createSubFolder = document.getElementById('createSubFolder').checked;
            const downloadMode = document.getElementById('downloadMode').value;

            if (!platform) {
                alert(getTranslation('messages.selectPlatform'));
                return;
            }

            if (!outputDir) {
                alert(getTranslation('messages.selectDirectory'));
                return;
            }

            // ÊûÑÂª∫Ëá™ÂÆö‰πâÈÖçÁΩÆ
            let customConfig = null;
            if (downloadMode === 'custom') {
                const catalogSource = document.getElementById('catalogSource').value;
                const customBaseUrl = document.getElementById('customBaseUrl').value.trim();
                
                if (!customBaseUrl) {
                    alert(getTranslation('messages.provideBaseUrl'));
                    return;
                }
                
                // È™åËØÅbase URL
                try {
                    new URL(customBaseUrl);
                } catch (e) {
                    alert(getTranslation('messages.invalidBaseUrl'));
                    return;
                }
                
                if (catalogSource === 'file') {
                    if (!selectedCatalogPath) {
                        alert(getTranslation('messages.selectCatalogFile'));
                        return;
                    }
                    customConfig = {
                        mode: 'custom',
                        catalogSource: 'file',
                        catalogFilePath: selectedCatalogPath,
                        baseUrl: customBaseUrl
                    };
                } else {
                    const catalogUrl = document.getElementById('catalogUrl').value.trim();
                    if (!catalogUrl) {
                        alert(getTranslation('messages.provideCatalogUrl'));
                        return;
                    }
                    
                    // È™åËØÅcatalog URL
                    try {
                        new URL(catalogUrl);
                    } catch (e) {
                        alert(getTranslation('messages.invalidCatalogUrl'));
                        return;
                    }
                    
                    customConfig = {
                        mode: 'custom',
                        catalogSource: 'url',
                        catalogUrl: catalogUrl,
                        baseUrl: customBaseUrl
                    };
                }
            }

            // ‰øùÂ≠òÁî®Êà∑ÈÄâÊã©
            if (isElectron) {
                try {
                    const configToSave = {
                        lastPlatform: platform,
                        lastDownloadPath: outputDir,
                        lastConcurrent: concurrent,
                        createSubFolder: createSubFolder
                    };
                    
                    if (customConfig) {
                        configToSave.downloadMode = 'custom';
                        configToSave.customCatalogSource = customConfig.catalogSource;
                        configToSave.customCatalogUrl = customConfig.catalogUrl || '';
                        configToSave.customBaseUrl = customConfig.baseUrl;
                    }
                    
                    await window.electronAPI.saveUserConfig(configToSave);
                } catch (error) {
                    console.error('Failed to save user config:', error);
                }
            }

            // ÂºÄÂßã‰∏ãËΩΩ
            if (isElectron) {
                await startDownloadElectron(platform, outputDir, concurrent, createSubFolder, customConfig);
            } else {
                alert(getTranslation('messages.needElectron'));
            }
        });

        // ÂÅúÊ≠¢‰∏ãËΩΩÂ§ÑÁêÜ
        document.getElementById('cancelBtn').addEventListener('click', async function() {
            if (!downloadInProgress || !isElectron) {
                return;
            }
            
            try {
                const result = await window.electronAPI.stopDownload();
                if (result.success) {
                    addLog(getTranslation('log.stopRequested'), 'info');
                } else {
                    addLog(getTranslation('log.stopFailed'), 'error');
                }
            } catch (error) {
                addLog(getTranslation('messages.downloadError') + error.message, 'error');
            }
        });

        // ÈÄâÊã©ÁõÆÂΩïÊåâÈíÆÂ§ÑÁêÜ
        document.addEventListener('click', function(e) {
            if (e.target.id === 'selectDirBtn') {
                selectDirectory();
            } else if (e.target.id === 'outputDir') {
                // ÁÇπÂáªËæìÂÖ•Ê°Ü‰πüËß¶ÂèëÁõÆÂΩïÈÄâÊã©
                selectDirectory();
            }
        });

        // ÁõëÂê¨Â§çÈÄâÊ°ÜÂèòÂåñÔºåÂÆûÊó∂‰øùÂ≠òÈÖçÁΩÆ
        document.addEventListener('change', function(e) {
            if (e.target.id === 'createSubFolder' && isElectron) {
                const createSubFolder = e.target.checked;
                try {
                    window.electronAPI.saveUserConfig({
                        createSubFolder: createSubFolder
                    }).then(() => {
                        addLog(createSubFolder ? getTranslation('messages.createSubFolderEnabled') : getTranslation('messages.createSubFolderDisabled'), 'info');
                    }).catch(error => {
                        console.error('Failed to save config:', error);
                    });
                } catch (error) {
                    console.error('Failed to save config:', error);
                }
            }
        });

        async function selectDirectory() {
            if (!isElectron) {
                alert(getTranslation('messages.needElectron'));
                return;
            }

            try {
                const selectedPath = await window.electronAPI.selectDirectory();
                if (selectedPath) {
                    document.getElementById('outputDir').value = selectedPath;
                    document.getElementById('outputDir').placeholder = selectedPath;
                    addLog(getTranslation('messages.directorySelected') + selectedPath, 'info');
                    
                    // ‰øùÂ≠òÂà∞Áî®Êà∑ÈÖçÁΩÆ
                    const createSubFolder = document.getElementById('createSubFolder').checked;
                    await window.electronAPI.saveUserConfig({
                        lastDownloadPath: selectedPath,
                        createSubFolder: createSubFolder
                    });
                }
            } catch (error) {
                addLog(getTranslation('messages.directorySelectError') + error.message, 'error');
            }
        }

        async function startDownloadElectron(platform, outputDir, concurrent, createSubFolder, customConfig = null) {
            downloadInProgress = true;
            
            // ÊòæÁ§∫ËøõÂ∫¶Âå∫ÂüüÂíåÊó•ÂøóÂå∫Âüü
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('logSection').style.display = 'block';
            
            // Á¶ÅÁî®Êèê‰∫§ÊåâÈíÆÔºåÊòæÁ§∫ÂèñÊ∂àÊåâÈíÆ
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = getTranslation('buttons.downloading');
            cancelBtn.style.display = 'block';

            // Ê∏ÖÁ©∫Êó•Âøó
            logContainer.innerHTML = '';
            
            try {
                addLog(formatTranslation('log.startingDownload', { platform: platform.toUpperCase() }), 'info');
                
                const result = await window.electronAPI.startDownload({
                    platform: platform,
                    outputDir: outputDir,
                    concurrent: concurrent,
                    createSubFolder: createSubFolder,
                    customConfig: customConfig
                });

                if (result && !result.success) {
                    addLog(getTranslation('log.downloadStartFailed') + result.error, 'error');
                    onDownloadStopped();
                }

            } catch (error) {
                addLog(getTranslation('log.error') + error.message, 'error');
                onDownloadStopped();
            }
        }

        function updateProgress(data) {
            const { total, completed, failed, currentFile } = data;
            
            document.getElementById('totalFiles').textContent = total || 0;
            document.getElementById('completedFiles').textContent = completed || 0;
            document.getElementById('failedFiles').textContent = failed || 0;
            
            const percentage = total > 0 ? Math.round((completed + failed) / total * 100) : 0;
            document.getElementById('percentage').textContent = percentage + '%';
            document.getElementById('progressFill').style.width = percentage + '%';
            
            if (currentFile) {
                document.getElementById('statusText').textContent = getTranslation('progress.downloading') + ': ' + currentFile;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàê
            if (total > 0 && (completed + failed) >= total) {
                document.getElementById('statusText').textContent = failed === 0 ? getTranslation('progress.completed') : getTranslation('progress.completedWithErrors');
            }
        }

        function addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ÂÅúÊ≠¢‰∏ãËΩΩÁä∂ÊÄÅÊõ¥Êñ∞
        function onDownloadStopped() {
            downloadInProgress = false;
            const submitBtn = document.getElementById('submitBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            submitBtn.disabled = false;
            submitBtn.textContent = getTranslation('buttons.startDownload');
            cancelBtn.style.display = 'none';
            
            const statusText = document.getElementById('statusText');
            if (!statusText.textContent.includes(getTranslation('progress.completed').split('!')[0])) {
                statusText.textContent = getTranslation('progress.stopped');
            }
        }

        // ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ
        window.addEventListener('error', function(e) {
            console.error('Global error:', e);
            addLog(getTranslation('messages.appError') + e.message, 'error');
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e);
            addLog(getTranslation('messages.asyncError') + e.reason, 'error');
        });
    </script>
</body>
</html>